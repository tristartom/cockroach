// Code generated by protoc-gen-gogo.
// source: cockroach/proto/errors.proto
// DO NOT EDIT!

package proto

import proto1 "github.com/gogo/protobuf/proto"
import math "math"

// discarding unused import gogoproto "gogoproto/gogo.pb"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = math.Inf

// TransactionRestart indicates how an error should be handled in a
// transactional context.
type TransactionRestart int32

const (
	// ABORT (the default) is for errors that are considered permanent
	// and should abort the transaction.
	TransactionRestart_ABORT TransactionRestart = 0
	// BACKOFF is for errors that can retried by restarting the transaction
	// after an exponential backoff.
	TransactionRestart_BACKOFF TransactionRestart = 1
	// IMMEDIATE is for errors that can be retried by restarting the
	// transaction immediately.
	TransactionRestart_IMMEDIATE TransactionRestart = 2
)

var TransactionRestart_name = map[int32]string{
	0: "ABORT",
	1: "BACKOFF",
	2: "IMMEDIATE",
}
var TransactionRestart_value = map[string]int32{
	"ABORT":     0,
	"BACKOFF":   1,
	"IMMEDIATE": 2,
}

func (x TransactionRestart) Enum() *TransactionRestart {
	p := new(TransactionRestart)
	*p = x
	return p
}
func (x TransactionRestart) String() string {
	return proto1.EnumName(TransactionRestart_name, int32(x))
}
func (x *TransactionRestart) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(TransactionRestart_value, data, "TransactionRestart")
	if err != nil {
		return err
	}
	*x = TransactionRestart(value)
	return nil
}

// A NotLeaderError indicates that the current range is not the
// leader. If the leader is known, its Replica is set in the error.
type NotLeaderError struct {
	Leader           *Replica `protobuf:"bytes,1,opt,name=leader" json:"leader,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *NotLeaderError) Reset()         { *m = NotLeaderError{} }
func (m *NotLeaderError) String() string { return proto1.CompactTextString(m) }
func (*NotLeaderError) ProtoMessage()    {}

func (m *NotLeaderError) GetLeader() *Replica {
	if m != nil {
		return m.Leader
	}
	return nil
}

// A RangeNotFoundError indicates that a command was sent to a range
// which is not hosted on this store.
type RangeNotFoundError struct {
	RaftID           int64  `protobuf:"varint,1,opt,name=raft_id" json:"raft_id"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RangeNotFoundError) Reset()         { *m = RangeNotFoundError{} }
func (m *RangeNotFoundError) String() string { return proto1.CompactTextString(m) }
func (*RangeNotFoundError) ProtoMessage()    {}

func (m *RangeNotFoundError) GetRaftID() int64 {
	if m != nil {
		return m.RaftID
	}
	return 0
}

// A RangeKeyMismatchError indicates that a command was sent to a
// range which did not contain the key(s) specified by the command.
type RangeKeyMismatchError struct {
	RequestStartKey  Key              `protobuf:"bytes,1,opt,name=request_start_key,customtype=Key" json:"request_start_key"`
	RequestEndKey    Key              `protobuf:"bytes,2,opt,name=request_end_key,customtype=Key" json:"request_end_key"`
	Range            *RangeDescriptor `protobuf:"bytes,3,opt,name=range" json:"range,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *RangeKeyMismatchError) Reset()         { *m = RangeKeyMismatchError{} }
func (m *RangeKeyMismatchError) String() string { return proto1.CompactTextString(m) }
func (*RangeKeyMismatchError) ProtoMessage()    {}

func (m *RangeKeyMismatchError) GetRange() *RangeDescriptor {
	if m != nil {
		return m.Range
	}
	return nil
}

// A ReadWithinUncertaintyIntervalError indicates that a read at timestamp
// encountered a versioned value at existing_timestamp within the uncertainty
// interval of the reader.
// The read should be retried at existing_timestamp+1.
type ReadWithinUncertaintyIntervalError struct {
	Timestamp         Timestamp `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp"`
	ExistingTimestamp Timestamp `protobuf:"bytes,2,opt,name=existing_timestamp" json:"existing_timestamp"`
	XXX_unrecognized  []byte    `json:"-"`
}

func (m *ReadWithinUncertaintyIntervalError) Reset()         { *m = ReadWithinUncertaintyIntervalError{} }
func (m *ReadWithinUncertaintyIntervalError) String() string { return proto1.CompactTextString(m) }
func (*ReadWithinUncertaintyIntervalError) ProtoMessage()    {}

func (m *ReadWithinUncertaintyIntervalError) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

func (m *ReadWithinUncertaintyIntervalError) GetExistingTimestamp() Timestamp {
	if m != nil {
		return m.ExistingTimestamp
	}
	return Timestamp{}
}

// A TransactionAbortedError indicates that the transaction was
// aborted by another concurrent transaction.
type TransactionAbortedError struct {
	Txn              Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *TransactionAbortedError) Reset()         { *m = TransactionAbortedError{} }
func (m *TransactionAbortedError) String() string { return proto1.CompactTextString(m) }
func (*TransactionAbortedError) ProtoMessage()    {}

func (m *TransactionAbortedError) GetTxn() Transaction {
	if m != nil {
		return m.Txn
	}
	return Transaction{}
}

// A TransactionPushError indicates that the transaction could not
// continue because it encountered a write intent from another
// transaction which it was unable to push.
type TransactionPushError struct {
	// txn can be null in the event the push error happened to a
	// non-transactional method.
	Txn              *Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn,omitempty"`
	PusheeTxn        Transaction  `protobuf:"bytes,2,opt,name=pushee_txn" json:"pushee_txn"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *TransactionPushError) Reset()         { *m = TransactionPushError{} }
func (m *TransactionPushError) String() string { return proto1.CompactTextString(m) }
func (*TransactionPushError) ProtoMessage()    {}

func (m *TransactionPushError) GetTxn() *Transaction {
	if m != nil {
		return m.Txn
	}
	return nil
}

func (m *TransactionPushError) GetPusheeTxn() Transaction {
	if m != nil {
		return m.PusheeTxn
	}
	return Transaction{}
}

// A TransactionRetryError indicates that the transaction must be
// retried, usually with an increased transaction timestamp. The
// transaction struct to use is returned with the error.
type TransactionRetryError struct {
	Txn              Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *TransactionRetryError) Reset()         { *m = TransactionRetryError{} }
func (m *TransactionRetryError) String() string { return proto1.CompactTextString(m) }
func (*TransactionRetryError) ProtoMessage()    {}

func (m *TransactionRetryError) GetTxn() Transaction {
	if m != nil {
		return m.Txn
	}
	return Transaction{}
}

// A TransactionStatusError indicates that the transaction status is
// incompatible with the requested operation. This might mean the
// transaction has already been committed. It might also be the case
// that the request to modify the transaction failed due to a
// regression in transaction epoch or timestamp, both of which may
// only monotonically increase.
type TransactionStatusError struct {
	Txn              Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn"`
	Msg              string      `protobuf:"bytes,2,opt,name=msg" json:"msg"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *TransactionStatusError) Reset()         { *m = TransactionStatusError{} }
func (m *TransactionStatusError) String() string { return proto1.CompactTextString(m) }
func (*TransactionStatusError) ProtoMessage()    {}

func (m *TransactionStatusError) GetTxn() Transaction {
	if m != nil {
		return m.Txn
	}
	return Transaction{}
}

func (m *TransactionStatusError) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// A WriteIntentError indicates that a write intent belonging to
// another transaction was encountered leading to a read/write or
// write/write conflict. The Key at which the intent was encountered
// is set, as is the Txn record for the intent's transaction.
// Resolved is set if the intent was successfully resolved, meaning
// the client may retry the operation immediately. If Resolved is
// false, the client should back off and retry.
type WriteIntentError struct {
	Key              Key         `protobuf:"bytes,1,opt,name=key,customtype=Key" json:"key"`
	Txn              Transaction `protobuf:"bytes,2,opt,name=txn" json:"txn"`
	Resolved         bool        `protobuf:"varint,3,opt,name=resolved" json:"resolved"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *WriteIntentError) Reset()         { *m = WriteIntentError{} }
func (m *WriteIntentError) String() string { return proto1.CompactTextString(m) }
func (*WriteIntentError) ProtoMessage()    {}

func (m *WriteIntentError) GetTxn() Transaction {
	if m != nil {
		return m.Txn
	}
	return Transaction{}
}

func (m *WriteIntentError) GetResolved() bool {
	if m != nil {
		return m.Resolved
	}
	return false
}

// A WriteTooOldError indicates that a write encountered a versioned
// value newer than its timestamp, making it impossible to rewrite
// history. The write should be retried at existing_timestamp+1.
type WriteTooOldError struct {
	Timestamp         Timestamp `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp"`
	ExistingTimestamp Timestamp `protobuf:"bytes,2,opt,name=existing_timestamp" json:"existing_timestamp"`
	XXX_unrecognized  []byte    `json:"-"`
}

func (m *WriteTooOldError) Reset()         { *m = WriteTooOldError{} }
func (m *WriteTooOldError) String() string { return proto1.CompactTextString(m) }
func (*WriteTooOldError) ProtoMessage()    {}

func (m *WriteTooOldError) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

func (m *WriteTooOldError) GetExistingTimestamp() Timestamp {
	if m != nil {
		return m.ExistingTimestamp
	}
	return Timestamp{}
}

// An OpRequiresTxnError indicates that a command required to be
// carried out in a transactional context but was not.
// For example, a Scan which spans ranges requires a transaction.
// The operation should be retried inside of a transaction.
type OpRequiresTxnError struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *OpRequiresTxnError) Reset()         { *m = OpRequiresTxnError{} }
func (m *OpRequiresTxnError) String() string { return proto1.CompactTextString(m) }
func (*OpRequiresTxnError) ProtoMessage()    {}

// A ConditionFailedError indicates that the expected value
// of a ConditionalPutRequest was not found, either
// because it was missing or was not equal. The error will
// contain the actual value found.
type ConditionFailedError struct {
	ActualValue      *Value `protobuf:"bytes,1,opt,name=actual_value" json:"actual_value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ConditionFailedError) Reset()         { *m = ConditionFailedError{} }
func (m *ConditionFailedError) String() string { return proto1.CompactTextString(m) }
func (*ConditionFailedError) ProtoMessage()    {}

func (m *ConditionFailedError) GetActualValue() *Value {
	if m != nil {
		return m.ActualValue
	}
	return nil
}

// ErrorDetail is a union type containing all available errors.
type ErrorDetail struct {
	NotLeader                     *NotLeaderError                     `protobuf:"bytes,1,opt,name=not_leader" json:"not_leader,omitempty"`
	RangeNotFound                 *RangeNotFoundError                 `protobuf:"bytes,2,opt,name=range_not_found" json:"range_not_found,omitempty"`
	RangeKeyMismatch              *RangeKeyMismatchError              `protobuf:"bytes,3,opt,name=range_key_mismatch" json:"range_key_mismatch,omitempty"`
	ReadWithinUncertaintyInterval *ReadWithinUncertaintyIntervalError `protobuf:"bytes,4,opt,name=read_within_uncertainty_interval" json:"read_within_uncertainty_interval,omitempty"`
	TransactionAborted            *TransactionAbortedError            `protobuf:"bytes,5,opt,name=transaction_aborted" json:"transaction_aborted,omitempty"`
	TransactionPush               *TransactionPushError               `protobuf:"bytes,6,opt,name=transaction_push" json:"transaction_push,omitempty"`
	TransactionRetry              *TransactionRetryError              `protobuf:"bytes,7,opt,name=transaction_retry" json:"transaction_retry,omitempty"`
	TransactionStatus             *TransactionStatusError             `protobuf:"bytes,8,opt,name=transaction_status" json:"transaction_status,omitempty"`
	WriteIntent                   *WriteIntentError                   `protobuf:"bytes,9,opt,name=write_intent" json:"write_intent,omitempty"`
	WriteTooOld                   *WriteTooOldError                   `protobuf:"bytes,10,opt,name=write_too_old" json:"write_too_old,omitempty"`
	OpRequiresTxn                 *OpRequiresTxnError                 `protobuf:"bytes,11,opt,name=op_requires_txn" json:"op_requires_txn,omitempty"`
	ConditionFailed               *ConditionFailedError               `protobuf:"bytes,12,opt,name=condition_failed" json:"condition_failed,omitempty"`
	XXX_unrecognized              []byte                              `json:"-"`
}

func (m *ErrorDetail) Reset()         { *m = ErrorDetail{} }
func (m *ErrorDetail) String() string { return proto1.CompactTextString(m) }
func (*ErrorDetail) ProtoMessage()    {}

func (m *ErrorDetail) GetNotLeader() *NotLeaderError {
	if m != nil {
		return m.NotLeader
	}
	return nil
}

func (m *ErrorDetail) GetRangeNotFound() *RangeNotFoundError {
	if m != nil {
		return m.RangeNotFound
	}
	return nil
}

func (m *ErrorDetail) GetRangeKeyMismatch() *RangeKeyMismatchError {
	if m != nil {
		return m.RangeKeyMismatch
	}
	return nil
}

func (m *ErrorDetail) GetReadWithinUncertaintyInterval() *ReadWithinUncertaintyIntervalError {
	if m != nil {
		return m.ReadWithinUncertaintyInterval
	}
	return nil
}

func (m *ErrorDetail) GetTransactionAborted() *TransactionAbortedError {
	if m != nil {
		return m.TransactionAborted
	}
	return nil
}

func (m *ErrorDetail) GetTransactionPush() *TransactionPushError {
	if m != nil {
		return m.TransactionPush
	}
	return nil
}

func (m *ErrorDetail) GetTransactionRetry() *TransactionRetryError {
	if m != nil {
		return m.TransactionRetry
	}
	return nil
}

func (m *ErrorDetail) GetTransactionStatus() *TransactionStatusError {
	if m != nil {
		return m.TransactionStatus
	}
	return nil
}

func (m *ErrorDetail) GetWriteIntent() *WriteIntentError {
	if m != nil {
		return m.WriteIntent
	}
	return nil
}

func (m *ErrorDetail) GetWriteTooOld() *WriteTooOldError {
	if m != nil {
		return m.WriteTooOld
	}
	return nil
}

func (m *ErrorDetail) GetOpRequiresTxn() *OpRequiresTxnError {
	if m != nil {
		return m.OpRequiresTxn
	}
	return nil
}

func (m *ErrorDetail) GetConditionFailed() *ConditionFailedError {
	if m != nil {
		return m.ConditionFailed
	}
	return nil
}

// Error is a generic represesentation including a string message
// and information about retryability.
type Error struct {
	// Message is a human-readable error message.
	Message string `protobuf:"bytes,1,opt,name=message" json:"message"`
	// If retryable is true, the error condition may be transient and the failed
	// operation may be retried (within the same transaction).
	Retryable bool `protobuf:"varint,2,opt,name=retryable" json:"retryable"`
	// If transaction_restart is not ABORT, the error condition may be handled by
	// restarting the transaction (with or without a backoff).
	TransactionRestart TransactionRestart `protobuf:"varint,4,opt,name=transaction_restart,enum=cockroach.proto.TransactionRestart" json:"transaction_restart"`
	// If an ErrorDetail is present, it may contain additional structured data
	// about the error.
	Detail           *ErrorDetail `protobuf:"bytes,3,opt,name=detail" json:"detail,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto1.CompactTextString(m) }
func (*Error) ProtoMessage()    {}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Error) GetRetryable() bool {
	if m != nil {
		return m.Retryable
	}
	return false
}

func (m *Error) GetTransactionRestart() TransactionRestart {
	if m != nil {
		return m.TransactionRestart
	}
	return TransactionRestart_ABORT
}

func (m *Error) GetDetail() *ErrorDetail {
	if m != nil {
		return m.Detail
	}
	return nil
}

func init() {
	proto1.RegisterEnum("cockroach.proto.TransactionRestart", TransactionRestart_name, TransactionRestart_value)
}
func (this *ErrorDetail) GetValue() interface{} {
	if this.NotLeader != nil {
		return this.NotLeader
	}
	if this.RangeNotFound != nil {
		return this.RangeNotFound
	}
	if this.RangeKeyMismatch != nil {
		return this.RangeKeyMismatch
	}
	if this.ReadWithinUncertaintyInterval != nil {
		return this.ReadWithinUncertaintyInterval
	}
	if this.TransactionAborted != nil {
		return this.TransactionAborted
	}
	if this.TransactionPush != nil {
		return this.TransactionPush
	}
	if this.TransactionRetry != nil {
		return this.TransactionRetry
	}
	if this.TransactionStatus != nil {
		return this.TransactionStatus
	}
	if this.WriteIntent != nil {
		return this.WriteIntent
	}
	if this.WriteTooOld != nil {
		return this.WriteTooOld
	}
	if this.OpRequiresTxn != nil {
		return this.OpRequiresTxn
	}
	if this.ConditionFailed != nil {
		return this.ConditionFailed
	}
	return nil
}

func (this *ErrorDetail) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *NotLeaderError:
		this.NotLeader = vt
	case *RangeNotFoundError:
		this.RangeNotFound = vt
	case *RangeKeyMismatchError:
		this.RangeKeyMismatch = vt
	case *ReadWithinUncertaintyIntervalError:
		this.ReadWithinUncertaintyInterval = vt
	case *TransactionAbortedError:
		this.TransactionAborted = vt
	case *TransactionPushError:
		this.TransactionPush = vt
	case *TransactionRetryError:
		this.TransactionRetry = vt
	case *TransactionStatusError:
		this.TransactionStatus = vt
	case *WriteIntentError:
		this.WriteIntent = vt
	case *WriteTooOldError:
		this.WriteTooOld = vt
	case *OpRequiresTxnError:
		this.OpRequiresTxn = vt
	case *ConditionFailedError:
		this.ConditionFailed = vt
	default:
		return false
	}
	return true
}
